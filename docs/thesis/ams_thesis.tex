\documentclass[12pt,english]{report}

% % % These packages imported by Abe
\usepackage{xargs} 
%has to load before umlthesistemplate
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=purple,backgroundcolor=purple!25,bordercolor=purple,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

%Has to load before umlthesistemplate
\usepackage{auto-pst-pdf}

%Can probably load anytime, but seems to work in advance...
\usepackage{graphviz}
\usepackage{microtype}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{relsize}

%For BNF
\usepackage{backnaur}

\usepackage[toc,page]{appendix}
% From https://tex.stackexchange.com/questions/163330/creating-figures-to-show-binary-values
%For showing bitfields in the control hardware
\usepackage{bytefield}
\newcommand{\colorbitbox}[3]{%
\rlap{\bitbox{#2}{\color{#1}\rule{\width}{\height}}}%
\bitbox{#2}{#3}}
\definecolor{lightcyan}{rgb}{0.84,1,1}
\definecolor{lightgreen}{rgb}{0.64,1,0.71}
\definecolor{lightred}{rgb}{1,0.7,0.71}
% % % End Abe's stuff

\usepackage{umlthesistemplate}

\title{Command Language for Single-User, Multi-Robot Swarm Control}
\author{Abraham M. Shultz}
\pastdegrees{B.S. Worcester Polytechnic Institute (2004) \and M.S. University of Massachusetts Lowell (2014)}
\degree{Doctor of Philosophy}
\department{Computer Science}
\university{University of Massachusetts Lowell}
\majorprofessor{Dr. Holly A. Yanco}
\majorproftitle{Dissertation Chair}
\members{Dr. Radhika Nagpal \and Dr. Jay McCarthy}
\date{ 3 December, 2018}

\includeapproval

\abstract{Command and control systems designed for a single operator to operate a single robot do not scale to control of swarms. %\citep{WangSearchScale}. 
Interfaces that require the user to attend to each robot overwhelm the user when the number of robots increases beyond 12 or 13 for uncrewed aerial vehicles (UAVs) and 3-9 for uncrewed ground vehicles (UGVs). % \citep{WangSearchScale}. 
As robot swarms increase beyond these bounds, the control system must shift to from controlling individual robots to controlling the swarm as a single entity or set of groups. 
However, the form this interface should take to permit easy and understandable control of the swarm is largely undefined.

Previous work in human-robot interaction (HRI) shows that multi-touch interfaces allow a scalable and direct mapping between the desires of the user and sequences of commands to robots. %\citep{micire2009multi}. 
By defining a mapping from user interface gestures to individual programs loaded on each robot, we can allow an individual to control arbitrarily large, heterogeneous swarms. This thesis presents an interface that extends previous work on multitouch interfaces for small groups of robots to larger swarms, and automates the process of converting command gestures into programs for each robot. 
The use of individual control programs rather than centralized control is important to realize the potential of swarms to continue to operate despite the possible failure of individual swarm robots.

The contributions of this thesis are a new swarm hardware platform, software to support it, and a user interface that converts user commands into programs for each robot in the swarm. 
The new swarm platform initially combined a wifi-enabled microcontroller with commodity mobility platforms sourced from childrenâ€™s toys to allow large swarms to be built at a low cost. 
While children's toys ultimately were not sufficiently reliable to serve as mobility platforms, the design of the controller was not bound to a specific mobility platform, and so was applied to 3-D printed mobility platforms. 
The user interface was defined by allowing users to select the gestures that they would use to issue commands to the swarm. 
It was discovered that as the size of the swarm increases, the gestures that users choose vary, particularly in the case of selection gestures. 
For small swarms, users will interact with individual robots, but as the swarm size increases beyond approximately ten members, users transition from commanding individual robots to selecting and commanding groups of robots. 
The resulting user gesture set, with some modification to remove ambiguity, can be translated into programs for individual robots, but the correctness of these programs is only provable in limited cases. 

%In order to maintain the low cost, sensors for the swarm robots were simulated with a top down camera. 
%The use of simulation allows individual swarm members to be constructed cheaply in the present, while leaving the path clear in the future to push computation to the individual members as computer hardware becomes cheaper and smaller.
}

\acknowledgments{ \input{ack.tex} }
\includetoc 
\maketitle

\begin{document}

\clearpage

\include{ch0_intro}

\include{ch1_related_work}

\include{ch2_swarm_hw_dev}

\include{ch3_gesture_collect}

\include{ch4_ui_design}

\include{ch5_program_gen}

\include{ch5.5_compiler}

\include{ch6_contributions}

\renewcommand{\bibname}{Literature Cited}

\singlespace
\bibliography{../proposal/swarm.bib}
%\bibliographystyle{apalike}
\doublespace
\begin{appendices}
\include{coding_doc}
\include{all_slides}
\end{appendices}

\end{document}
